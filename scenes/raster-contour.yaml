# contours calculated in shader aren't completely unreasonable - we will eventually have to generate vector
#  contours w/ elevation labels of course
# - the main issue is poor resolution in elevation tiles - we need to add support for zoom_offset < 0 !

global:
    sdk_api_key: ''
    gui_variables:
        - name: u_exaggerate
          style: hillshade
          label: Hillshade Exaggeration

sources:
    #normals:
    #    type: Raster
    #    url: https://elevation-tiles-prod.s3.amazonaws.com/normal/{z}/{x}/{y}.png
    #    url_params:
    #        api_key: global.sdk_api_key

    elevation:
        type: Raster
        url: https://tile.nextzen.org/tilezen/terrain/v1/256/terrarium/{z}/{x}/{y}.png
        #url: https://elevation-tiles-prod.s3.amazonaws.com/terrarium/{z}/{x}/{y}.png
        url_params:
            api_key: global.sdk_api_key
        max_zoom: 14
        #zoom_offset: -1  -- negative zoom_offset not supported
        filtering: nearest
        cache: terrarium

    #osm-raster:
    #    type: Raster
    #    #url: http://a.tile.stamen.com/terrain-background/{z}/{x}/{y}.jpg
    #    url: https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png
    #    url_subdomains: [a, b, c]
    #    rasters: [elevation]  #[terrain-normals]
    #    cache: osm-raster

    osmand-raster:
        type: Raster
        url: https://tile.osmand.net/hd/{z}/{x}/{y}.png
        #user-agent: OsmAnd~
        rasters: [elevation]
        cache: osmand-raster2x


styles:
    hillshade:
        base: polygons
        raster: custom
        texcoords: true
        shaders:
            defines:
                # orange/brown: #C56008
                CONTOUR_COLOR: vec4(0.773,0.376,0.031,1.)
                # not sure if there is any way to figure this out in shader
                ELEVATION_MAX_ZOOM: 14.0
            uniforms:
                u_exaggerate: 1.5
                # https://github.com/der-stefan/OpenTopoMap/blob/master/mapnik/relief_color_text_file.txt
                u_terrain_color: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAABCAYAAABzE5aMAAAAU0lEQVR4nGMUrGD+b67lxBAgo8vgL6PD8OvzZ4ZfXz4z/P78meHXl09w/q/PEPz7y2eGX58/wcX+/WNi+PeXCSv9F4c4nObgIArz8/Mz8PHxEaQBkIhP/pBqnoYAAAAASUVORK5CYII=
                # this colormap is based on matplotlib terrain colormap
                #data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAABCAYAAAD9yd/wAAAAJElEQVR4nAEZAOb/ADMzmf8Amf//AMxm////mf+AXFT//////7WBEIg9mVbsAAAAAElFTkSuQmCC
            blocks:
                global: |
                    #ifdef TANGRAM_FRAGMENT_SHADER
                    float getElevation(sampler2D tex, vec2 uv) {
                        // Tangram doesn't use GLSL #version statement - need #version 130 for texelFetch
                        // - might be able to use extension - shader: {extensions: ... } }
                        // - for now, we just set `filtering: nearest` for source and use texture2D (mapbox-gl
                        //  also uses nearest, but does two passes, so 2nd pass linearly interpolates grad)
                        // data format: https://github.com/tilezen/joerd/blob/master/docs/formats.md
                        vec4 h = texture2D(tex, uv);  //texelFetch(tex, px, 0);
                        return (h.r*256. + h.g + h.b/256.)*255. - 32768.;  // in meters
                    }
                    //
                    //float getElevationLerp(sampler2D tex, vec2 uv, vec2 duv)
                    //{
                    //  vec2 ij = uv/duv;
                    //  vec2 uv00 = (floor(ij) + 0.5)*duv;
                    //  vec2 uv11 = uv00 + duv;
                    //  float t00 = getElevation(tex, vec2(uv00.x, uv00.y));
                    //  float t10 = getElevation(tex, vec2(uv11.x, uv00.y));
                    //  float t01 = getElevation(tex, vec2(uv00.x, uv11.y));
                    //  float t11 = getElevation(tex, vec2(uv11.x, uv11.y));
                    //  vec2 f = fract(ij);  //ij - floor(ij);
                    //  float t0 = t00 + f.x*(t10 - t00);
                    //  float t1 = t01 + f.x*(t11 - t01);
                    //  return t0 + f.y*(t1 - t0);  //mix(mix(t00, t10, f.x), mix(t01, t11, f.x), f.y);
                    //}
                    #endif
                normal: |
                    // Normal from heightmap - adapted from
                    // - http://stackoverflow.com/questions/5281261/generating-a-normal-map-from-a-height-map
                    // - http://stackoverflow.com/questions/15178225/normal-map-from-height-map-artifact
                    // fancier calculations: hillshade_prepare.fragment.glsl , hillshade.fragment.glsl in
                    //  mapbox/maplibre-gl-js
                    // Sample heightmap at center, left, right, above, below
                    vec2 duv = 1./rasterPixelSize(1);
                    //vec2 uv = currentRasterUV(1);

                    //vec2 ij = currentRasterUV(1) * rasterPixelSize(1);
                    //vec2 cen_ij = floor(ij) + 0.5;
                    //vec2 uv = cen_ij*duv;
                    //float h00 = getElevation(u_rasters[1], uv - duv);
                    //float h01 = getElevation(u_rasters[1], uv + vec2(-duv.x, 0.));
                    //float h02 = getElevation(u_rasters[1], uv + vec2(-duv.x, duv.y));
                    //float h10 = getElevation(u_rasters[1], uv + vec2(0., -duv.y));
                    //float h11 = getElevation(u_rasters[1], uv);
                    //float h12 = getElevation(u_rasters[1], uv + vec2(0., duv.y));
                    //float h20 = getElevation(u_rasters[1], uv + vec2(duv.x, -duv.y));
                    //float h21 = getElevation(u_rasters[1], uv + vec2(duv.x, 0.));
                    //float h22 = getElevation(u_rasters[1], uv + duv);


                    vec2 f = ij - cen_ij;
                    vec3 vfx = f.x > 0. ? vec3(1.-f.x, f.x, 0.) : vec3(0., -f.x, 1.+f.x);
                    vec3 vfy = f.y > 0. ? vec3(1.-f.y, f.y, 0.) : vec3(0., -f.y, 1.+f.y);
                    mat3 hmat = mat3(h00, h01, h02, h10, h11, h12, h20, h21, h22);
                    float elev = dot(hmat*vfx, vfy);



                    vec2 ij = currentRasterUV(1) * rasterPixelSize(1);
                    vec2 cen_ij = floor(ij) + 0.5;
                    vec2 uv = cen_ij*duv;
                    float h11 = getElevation(u_rasters[1], uv);
                    float h01 = getElevation(u_rasters[1], uv + vec2(-duv.x, 0.));
                    float h21 = getElevation(u_rasters[1], uv + vec2( duv.x, 0.));
                    float h10 = getElevation(u_rasters[1], uv + vec2(0., -duv.y));
                    float h12 = getElevation(u_rasters[1], uv + vec2(0.,  duv.y));

                    // no underwater terrain for now
                    float hscale = elev > 0. ? u_exaggerate : 0.; // /pow(u_meters_per_pixel, 0.7)/65536.;
                    // proj meters per elevation tile pixel (u_tile_origin.z is tile zoom, u_map_position.z is real zoom)
                    vec2 dxy_elev = 2.*3.141592*6378137.0*exp2(-min(ELEVATION_MAX_ZOOM, u_tile_origin.z))*duv;

                    vec2 f = ij - cen_ij;
                    // 2nd order finite diff to estimate 2nd deriv
                    vec2 curv = vec2(h21 - 2.*h11 + h01, h12 - 2.*h11 + h10)/dxy_elev;
                    vec2 grad0 = vec2(h21 - h01, h12 - h10)/2.0;
                    vec2 grad = (grad0 + f*curv)/dxy_elev;
                    float elev = h11 + grad0*f + 0.5*f*f*dxy_elev*curv;
                    normal = normalize(vec3(-hscale*grad, 1.));



                    // or ...
                    float dhx21 = h21 - h11;
                    float dhx10 = h11 - h01;
                    float dhy21 = h12 - h11;
                    float dhy10 = h11 - h10;
                    vec2 grad = vec2(dhx21*(0.5+f.x) + dhx10*(0.5-f.x), dhy21*(0.5+.y) + dhy10*(0.5-f.y))



                    vec2 ij = currentRasterUV(1) * rasterPixelSize(1);
                    vec2 rnd_ij = floor(ij + 0.5);  // round() is GLSL 1.30
                    vec2 uv = rnd_ij*duv;
                    float h00 = getElevation(u_rasters[1], uv - 0.5*duv);
                    float h01 = getElevation(u_rasters[1], uv + 0.5*vec2(-duv.x, duv.y));
                    float h10 = getElevation(u_rasters[1], uv + 0.5*vec2(duv.x, -duv.y));
                    float h11 = getElevation(u_rasters[1], uv + 0.5*duv);

                    float dhx0 = h10 - h00;
                    float dhx1 = h11 - h01;
                    float dhy0 = h01 - h00;
                    float dhy1 = h11 - h10;
                    vec2 f = ij - rnd_ij + 0.5;

                    //float h0 = h00 + f.x*(h10 - h00);  //f.x*h10 + (1-f.x)*h00
                    //float h1 = h01 + f.x*(h11 - h01);
                    //float elev = h0 + f.y*(h1 - h0);
                    float elev = dot(mat2(h00, h01, h10, h11)*vec2(1.-f.x, f.x), vec2(1.-f.y, f.y));


                    //    float h11 = getElevationLerp(u_rasters[1], uv, duv);
                    //    float h01 = getElevationLerp(u_rasters[1], uv + vec2(-duv.x, 0.), duv);
                    //    float h21 = getElevationLerp(u_rasters[1], uv + vec2( duv.x, 0.), duv);
                    //    float h10 = getElevationLerp(u_rasters[1], uv + vec2(0., -duv.y), duv);
                    //    float h12 = getElevationLerp(u_rasters[1], uv + vec2(0.,  duv.y), duv);
                    //
                    //    //    float h11 = getElevation(u_rasters[1], uv);
                    //    //    float h01 = getElevation(u_rasters[1], uv + vec2(-duv.x, 0.));
                    //    //    float h21 = getElevation(u_rasters[1], uv + vec2( duv.x, 0.));
                    //    //    float h10 = getElevation(u_rasters[1], uv + vec2(0., -duv.y));
                    //    //    float h12 = getElevation(u_rasters[1], uv + vec2(0.,  duv.y));
                    //    // no underwater terrain for now
                    float hscale = elev > 0. ? u_exaggerate : 0.; // /pow(u_meters_per_pixel, 0.7)/65536.;
                    //    // proj meters per elevation tile pixel (u_tile_origin.z is tile zoom, u_map_position.z is real zoom)
                    //    //vec2 duv_clamp = min(uv + duv, 1. - 0.5*duv) - max(uv - duv, 0.5*duv);
                    vec2 dxy_elev = 2.*3.141592*6378137.0*exp2(-min(ELEVATION_MAX_ZOOM, u_tile_origin.z))*duv;  //_clamp;
                    //    //vec2 grad = vec2(h21 - h01, h12 - h10)/dxy_elev/2.0;
                    //    // interpolate between fwd and rev difference so as to reduce seam at tile border
                    //    // - mapbox-gl addresses this by adding 1 pixel border w/ data from neighboring tiles
                    //    vec2 gradp = vec2(h21 - h11, h12 - h11)/dxy_elev;  // for fwd difference
                    //    vec2 gradn = vec2(h11 - h01, h11 - h10)/dxy_elev;  // for rev difference
                    //    vec2 grad = mix(gradp, gradn, uv);

                    // note that this is dh/df
                    vec2 grad = vec2(f.y*dhx1 + (1.0 - f.y)*dhx0, f.x*dhy1 + (1.0 - f.x)*dhy0)/dxy_elev;
                    normal = normalize(vec3(-hscale*grad, 1.));

                color: |
                    float z = u_map_position.z;
                    if(z < 10.) {
                        vec4 tint = texture2D(u_terrain_color, vec2(elev/5000., 0.5));
                        color = mix(sampleRaster(0), tint, 0.5);
                    } else {
                        // slope from gradient calculated above
                        float slope = length(grad);
                        // contour line radius in pixels
                        //float linehw = 0.5;
                        // spacing between contour lines in meters - 10m has too many artifacts
                        float interval = z >= 13.5 ? 25. : z >= 11.5 ? 50. : 100.;  //z >= 11. ? 100. : 200.;
                        float zstep = z >= 13.5 ? 13.5 : z >= 11.5 ? 11.5 : 9.5;
                        float linehw = mix(0.3, 0.5, clamp(0.5*(z - zstep), 0., 1.));
                        //float intervals[4] = float[](10., 20., 50., 100.);  -- need GLES 3
                        //float interval = 10.*clamp(exp2(15. - u_tile_origin.z), 1., 100.);
                        // no underwater contour lines!
                        float hc = max(elev, interval/2.);
                        // distance in pixels to nearest contour lines (above and below)
                        float dup = fract(hc/interval)*interval/slope / u_meters_per_pixel;
                        float ddn = abs(1. - fract(hc/interval))*interval/slope / u_meters_per_pixel;
                        // contour line pixel coverage
                        float cov = max(0.5 - dup + linehw, 0.) + max(0.5 - ddn + linehw, 0.);
                        // coarse lines
                        float coarsehw = 2.*linehw;  //0.75;
                        float coarse = z >= 13.5 ? 100. : z >= 11.5 ? 200. : 500.;
                        dup = fract(hc/coarse)*coarse/slope / u_meters_per_pixel;
                        ddn = abs(1. - fract(hc/coarse))*coarse/slope / u_meters_per_pixel;
                        cov += max(0.5 - dup + coarsehw, 0.) + max(0.5 - ddn + coarsehw, 0.);
                        // blend
                        color = mix(sampleRaster(0), CONTOUR_COLOR, min(cov, 1.));
                    }


lights:
    # point1: { type: point, position: [0, 0, 200px], origin: ground }
    light2: { type: directional, direction: [1, 1, -.9], diffuse: 0.8, ambient: 0.3 }


layers:
    earth:
        data: { source: osmand-raster }
        draw:
            hillshade:
                color: white
                order: 0
